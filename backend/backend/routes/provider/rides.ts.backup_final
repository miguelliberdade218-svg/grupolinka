import { Router, Request, Response, NextFunction } from 'express';
import { verifyFirebaseToken, requireDriverRole, ensureUserId } from '../../middleware/role-auth';
import { AuthenticatedUser } from '../../shared/types';
import { rideService } from '../../src/services/rideService';
import { insertRideSchema, updateRideSchema } from '../../shared/schema';
import { z } from 'zod';
import { db } from '../../db';
import { sql, eq, and } from 'drizzle-orm';
import { vehicles } from '../../shared/schema';
import { vehicleQueries } from '../../shared/db-helpers';

const router = Router();

// ‚úÖ CORRE√á√ÉO: Logger profissional
const logger = {
  info: (message: string, data?: any) => {
    if (process.env.NODE_ENV !== 'test') {
      console.log(`‚ÑπÔ∏è  PROVIDER-RIDES: ${message}`, data || '');
    }
  },
  error: (message: string, error?: any) => {
    console.error(`‚ùå PROVIDER-RIDES: ${message}`, error || '');
  },
  warn: (message: string, data?: any) => {
    console.warn(`‚ö†Ô∏è  PROVIDER-RIDES: ${message}`, data || '');
  }
};

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Fun√ß√£o para converter coordenadas em geometrias PostGIS
const createGeometryFromCoords = (lat: number, lng: number): string | null => {
  if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
    console.log('‚ùå [GEOMETRY] Coordenadas inv√°lidas:', { lat, lng });
    return null;
  }
  
  // Formato: POINT(lng lat) para PostGIS
  const wkt = `POINT(${lng} ${lat})`;
  console.log('‚úÖ [GEOMETRY] Geometria criada:', wkt);
  return wkt;
};

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Normalizador usando PostgreSQL
async function normalizeLocation(locationName: string): Promise<string> {
  if (!locationName || locationName.trim() === '') {
    return '';
  }

  try {
    console.log('üîç [PROVIDER-NORMALIZER] Normalizando:', locationName);
    
    const result = await db.execute<{ normalized: string }>(sql`
      SELECT normalize_location_name(${locationName}) as normalized
    `);
    
    // ‚úÖ CORRE√á√ÉO: Extra√ß√£o segura com type assertion
    let normalizedValue = locationName.split(',')[0].trim().toLowerCase();
    
    if (Array.isArray(result) && typeof result[0]?.normalized === 'string') {
      normalizedValue = result[0].normalized;
    } else if (result && Array.isArray((result as any).rows)) {
      normalizedValue = (result as any).rows[0]?.normalized || normalizedValue;
    } else if (result && typeof result === 'object') {
      const values = Object.values(result);
      if (Array.isArray(values[0]) && values[0].length > 0 && typeof values[0][0]?.normalized === 'string') {
        normalizedValue = values[0][0].normalized;
      }
    }
    
    console.log('‚úÖ [PROVIDER-NORMALIZER] Resultado:', {
      original: locationName,
      normalized: normalizedValue
    });
    
    return normalizedValue;

  } catch (error) {
    console.error('‚ùå [PROVIDER-NORMALIZER] Erro, usando fallback:', error);
    return locationName.split(',')[0].trim().toLowerCase();
  }
}

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Fun√ß√£o para chamar RPC do PostgreSQL (CORRIGIDA)
async function callPostgresFunction(functionName: string, params: any[] = []): Promise<any[]> {
  try {
    console.log('üß† [RPC] Chamando fun√ß√£o PostgreSQL:', {
      function: functionName,
      params,
      timestamp: new Date().toISOString()
    });

    // ‚úÖ VALIDAR FUN√á√ïES PERMITIDAS (SEGURAN√áA)
    const allowedFunctions = [
      'get_rides_smart_final',
      'normalize_location_name',
      'search_rides_by_location',
      'find_nearby_rides'
    ];

    if (!allowedFunctions.includes(functionName)) {
      throw new Error(`Fun√ß√£o n√£o permitida: ${functionName}`);
    }

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Construir query com par√¢metros usando template string
    let query: string;
    let queryParams: any[] = [];

    if (functionName === 'get_rides_smart_final') {
      const [search_from, search_to, radius_km, max_results] = params;
      
      query = `SELECT * FROM get_rides_smart_final($1, $2, $3, $4)`;
      queryParams = [
        search_from || '',
        search_to || '', 
        radius_km || 100,
        max_results || 50
      ];
    } else {
      // ‚úÖ FUN√á√ÉO GEN√âRICA PARA OUTRAS FUN√á√ïES
      const placeholders = params.map((_, index) => `$${index + 1}`).join(', ');
      query = `SELECT * FROM ${functionName}(${placeholders})`;
      queryParams = params;
    }

    console.log('üîç [RPC] Executando query:', {
      query,
      params: queryParams
    });

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Usar sql.raw corretamente sem par√¢metros extras
    // Construir a query com os par√¢metros j√° interpolados
    const rawQuery = sql.raw(query);
    
    // ‚úÖ CORRE√á√ÉO: Executar com par√¢metros usando m√©todo execute correto
    let result: any;
    
    // Tentar diferentes m√©todos de execu√ß√£o baseado na configura√ß√£o do Drizzle
    try {
      // M√©todo 1: Usando db.execute com sql template (mais seguro)
      if (functionName === 'get_rides_smart_final') {
        const [p1, p2, p3, p4] = queryParams;
        result = await db.execute(sql`
          SELECT * FROM get_rides_smart_final(${p1}, ${p2}, ${p3}, ${p4})
        `);
      } else {
        // Para outras fun√ß√µes, construir dinamicamente
        const dynamicSql = sql`SELECT * FROM ${sql.raw(functionName)}(${sql.join(queryParams.map(p => sql`${p}`), sql`, `)})`;
        result = await db.execute(dynamicSql);
      }
    } catch (executeError) {
      console.warn('‚ùå [RPC] M√©todo seguro falhou, tentando raw query:', executeError);
      
      // M√©todo 2: Fallback para raw query (menos seguro mas funcional)
      const interpolatedQuery = query.replace(/\$(\d+)/g, (_, index) => {
        const paramIndex = parseInt(index) - 1;
        const param = queryParams[paramIndex];
        return typeof param === 'string' ? `'${param.replace(/'/g, "''")}'` : param;
      });
      
      result = await db.execute(sql.raw(interpolatedQuery));
    }

    // ‚úÖ EXTRAIR RESULTADOS DE FORMA SEGURA
    let rows: any[] = [];
    
    if (Array.isArray(result)) {
      rows = result;
    } else if (result && typeof result === 'object' && 'rows' in result) {
      rows = (result as any).rows;
    } else if (result && typeof result === 'object') {
      const values = Object.values(result);
      if (Array.isArray(values[0])) {
        rows = values[0] as any[];
      }
    }

    console.log('‚úÖ [RPC] Fun√ß√£o executada com sucesso:', {
      function: functionName,
      results: rows.length,
      sample: rows[0] || 'Nenhum resultado'
    });

    return rows;

  } catch (error) {
    console.error('‚ùå [RPC] Erro ao executar fun√ß√£o:', error);
    throw error;
  }
}

// ‚úÖ CORRE√á√ÉO: Fun√ß√µes auxiliares type-safe
const safeString = (value: unknown, defaultValue: string = ''): string => {
  if (value === null || value === undefined || value === '') {
    return defaultValue;
  }
  return String(value);
};

const safeNumber = (value: unknown, defaultValue: number = 0): number => {
  if (value === null || value === undefined || value === '') {
    return defaultValue;
  }
  
  const num = Number(value);
  return isNaN(num) ? defaultValue : num;
};

const safeDate = (value: unknown, defaultValue: Date = new Date()): Date => {
  if (value === null || value === undefined || value === '') {
    return defaultValue;
  }
  
  try {
    const date = new Date(value as string);
    return isNaN(date.getTime()) ? defaultValue : date;
  } catch {
    return defaultValue;
  }
};

const normalizeLocationField = (value: unknown): string => {
  return safeString(value).toLowerCase();
};

// ‚úÖ CORRE√á√ÉO: Fun√ß√µes espec√≠ficas para query parameters
const getQueryString = (query: any, key: string, defaultValue: string = ''): string => {
  const value = query[key];
  return safeString(value, defaultValue);
};

const getQueryNumber = (query: any, key: string, defaultValue: number = 0): number => {
  const value = query[key];
  return safeNumber(value, defaultValue);
};

// ‚úÖ CORRE√á√ÉO: Interface para request autenticada
interface AuthenticatedRequest extends Request {
  user?: AuthenticatedUser;
}

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Helper para obter driverId com logs detalhados
const getDriverId = (req: AuthenticatedRequest): string | null => {
  console.log('üÜî [GET-DRIVER-ID] Verificando driverId...', {
    hasUser: !!req.user,
    userEmail: req.user?.email || 'NO_EMAIL',
    userId: req.user?.id || 'NO_ID',
    userUid: (req.user as any)?.uid || 'NO_UID',
    allUserKeys: req.user ? Object.keys(req.user) : 'NO_USER'
  });

  // ‚úÖ CORRE√á√ÉO ROBUSTA: Tentar todas as poss√≠veis propriedades de ID
  const user = req.user;
  if (!user) {
    console.log('‚ùå [GET-DRIVER-ID] req.user est√° undefined/null');
    return null;
  }
  
  // Tentar id primeiro, depois uid, depois email como fallback
  const possibleIds = [
    user.id,
    (user as any).uid,
    (user as any).user_id,
    (req.user as any)?.uid // ‚úÖ CORRE√á√ÉO: Acessar uid diretamente do req.user
  ].filter(Boolean);
  
  if (possibleIds.length === 0) {
    console.log('‚ùå [GET-DRIVER-ID] Nenhum ID encontrado no user:', {
      userKeys: Object.keys(user),
      userEmail: user.email
    });
    return null;
  }
  
  const driverId = possibleIds[0];
  console.log('‚úÖ [GET-DRIVER-ID] ID encontrado:', {
    driverId,
    allPossible: possibleIds,
    userKeys: Object.keys(user)
  });
  
  return driverId;
};

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Fun√ß√£o auxiliar para calcular receita de forma segura
const calculateRideRevenue = (ride: any): number => {
  // ‚úÖ CORRE√á√ÉO APLICADA: Usar safeNumber em todas as vari√°veis antes da compara√ß√£o
  const pricePerSeat = safeNumber(ride.pricePerSeat);
  const bookedSeatsNum = safeNumber((ride as any).bookedSeats);
  const occupiedSeatsNum = safeNumber((ride as any).occupiedSeats);
  const maxPassengersNum = safeNumber(ride.maxPassengers);
  
  // ‚úÖ CORRE√á√ÉO APLICADA: Compara√ß√£o segura com n√∫meros convertidos
  const actualOccupiedSeats = bookedSeatsNum > 0 
    ? bookedSeatsNum 
    : occupiedSeatsNum > 0 
      ? occupiedSeatsNum 
      : maxPassengersNum;
  
  return pricePerSeat * actualOccupiedSeats;
};

// ‚úÖ CORRE√á√ÉO: Fun√ß√£o para verificar propriedade da ride
const verifyRideOwnership = async (rideId: string, driverId: string): Promise<{ride: any, isOwner: boolean}> => {
  const ride = await rideService.getRideById(rideId);
  if (!ride) {
    return { ride: null, isOwner: false };
  }
  
  // ‚úÖ CORRE√á√ÉO: Compara√ß√£o segura de IDs
  const isOwner = safeString(ride.driverId) === driverId;
  return { ride, isOwner };
};

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Middleware de debug para a rota POST
const debugRideCreation = async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  console.log('üöó [RIDES-DEBUG] === INICIANDO CRIA√á√ÉO DE RIDE ===');
  console.log('üì® Headers recebidos:', {
    authorization: req.headers.authorization ? 'PRESENT' : 'MISSING',
    contentType: req.headers['content-type'],
    userAgent: req.headers['user-agent']
  });
  
  if (req.headers.authorization) {
    const token = req.headers.authorization.replace('Bearer ', '');
    console.log('üîê Token JWT:', {
      length: token.length,
      first20: token.substring(0, 20) + '...',
      last10: '...' + token.substring(token.length - 10),
      isJWT: token.split('.').length === 3
    });
  }
  
  console.log('üì¶ Body recebido:', {
    bodyKeys: Object.keys(req.body || {}),
    bodyPreview: req.body ? {
      fromCity: req.body.fromCity,
      toCity: req.body.toCity, 
      departureDate: req.body.departureDate,
      pricePerSeat: req.body.pricePerSeat,
      availableSeats: req.body.availableSeats,
      vehicle_uuid: req.body.vehicleId,
      // ‚úÖ‚úÖ‚úÖ NOVO: Debug das coordenadas
      fromLat: req.body.fromLat,
      fromLng: req.body.fromLng,
      toLat: req.body.toLat,
      toLng: req.body.toLng
    } : 'NO_BODY'
  });
  
  next();
};

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Rota POST com valida√ß√£o de vehicleId e GEOMETRIAS (CORRIGIDA)
router.post('/', 
  debugRideCreation,
  verifyFirebaseToken,
  ensureUserId,
  requireDriverRole, 
  async (req: AuthenticatedRequest, res: Response) => {
  try {
    console.log('üöó [RIDES-POST] === INICIANDO CRIA√á√ÉO DE RIDE ===');
    
    const driverId = getDriverId(req);
    const body = req.body;
    
    console.log('üìã Dados recebidos para cria√ß√£o:', {
      driverId,
      bodyKeys: Object.keys(body),
      bodyPreview: {
        fromCity: body.fromCity,
        toCity: body.toCity,
        departureDate: body.departureDate,
        pricePerSeat: body.pricePerSeat,
        vehicle_uuid: body.vehicleId,
        // ‚úÖ‚úÖ‚úÖ NOVO: Debug das coordenadas
        fromLat: body.fromLat,
        fromLng: body.fromLng,
        toLat: body.toLat,
        toLng: body.toLng
      },
      user: req.user ? {
        id: req.user.id,
        uid: (req.user as any).uid,
        email: req.user.email,
        roles: req.user.roles
      } : 'NO_USER'
    });
    
    if (!driverId) {
      console.log('‚ùå [RIDES-POST] driverId n√£o encontrado. User object:', req.user);
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }

    // ‚úÖ‚úÖ‚úÖ VALIDA√á√ÉO OBRIGAT√ìRIA DO VE√çCULO (NOVO)
    if (!body.vehicleId) {
      return res.status(400).json({
        success: false,
        error: 'Sele√ß√£o de ve√≠culo √© obrigat√≥ria'
      });
    }

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Usar helper para valida√ß√£o do ve√≠culo
    const vehicle = await vehicleQueries.getVehicleByIdAndDriver(body.vehicleId, driverId);

    if (!vehicle) {
      return res.status(404).json({
        success: false,
        error: 'Ve√≠culo n√£o encontrado ou n√£o pertence a voc√™'
      });
    }

    // ‚úÖ‚úÖ‚úÖ VERIFICAR CAPACIDADE DO VE√çCULO
    if (body.maxPassengers > vehicle.max_passengers) {
      return res.status(400).json({
        success: false,
        error: `N√∫mero de passageiros (${body.maxPassengers}) excede a capacidade do ve√≠culo (m√°ximo: ${vehicle.max_passengers})`
      });
    }

    console.log('‚úÖ [RIDES-POST] Valida√ß√£o do ve√≠culo conclu√≠da:', {
      vehicle_uuid: body.vehicleId,
      vehicleInfo: `${vehicle.make} ${vehicle.model} (${vehicle.color}) - ${vehicle.plate_number}`,
      capacity: `${body.maxPassengers}/${vehicle.max_passengers} passageiros`
    });

    logger.info('üìù Iniciando cria√ß√£o de ride', { driverId, vehicle_uuid: body.vehicleId });

    const { 
      fromAddress, 
      toAddress, 
      fromProvince,
      toProvince,
      fromCity,
      toCity,
      fromLocality,
      toLocality,
      departureDate, 
      departureTime,
      availableSeats, 
      maxPassengers, 
      pricePerSeat, 
      vehicleType, 
      additionalInfo,
      vehicleId, // ‚úÖ NOVO: Incluir vehicleId
      // ‚úÖ‚úÖ‚úÖ NOVO: Coordenadas para geometrias
      fromLat,
      fromLng,
      toLat,
      toLng
    } = body;

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Converter coordenadas para geometrias PostGIS
    console.log('üìç [COORD-DEBUG] Coordenadas recebidas:', {
      fromLat, fromLng, toLat, toLng,
      hasFromCoords: !!(fromLat && fromLng),
      hasToCoords: !!(toLat && toLng)
    });

    const fromGeom = createGeometryFromCoords(fromLat, fromLng);
    const toGeom = createGeometryFromCoords(toLat, toLng);

    console.log('üó∫Ô∏è [GEOMETRY-DEBUG] Geometrias criadas:', {
      fromGeom,
      toGeom,
      hasFromGeom: !!fromGeom,
      hasToGeom: !!toGeom
    });
    
    const rideInput = {
      driverId,
      fromAddress: safeString(fromAddress),
      toAddress: safeString(toAddress),
      fromProvince: normalizeLocationField(fromProvince),
      toProvince: normalizeLocationField(toProvince),
      fromCity: normalizeLocationField(fromCity),
      toCity: normalizeLocationField(toCity),
      fromLocality: normalizeLocationField(fromLocality),
      toLocality: normalizeLocationField(toLocality),
      // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: ADICIONAR GEOMETRIAS
      from_geom: fromGeom,
      to_geom: toGeom,
      departureDate: safeDate(departureDate),
      departureTime: safeString(departureTime, '08:00'),
      availableSeats: safeNumber(availableSeats, 1),
      maxPassengers: safeNumber(maxPassengers, 4),
      pricePerSeat: safeNumber(pricePerSeat, 0),
      vehicleType: safeString(vehicleType, 'car'),
      additionalInfo: safeString(additionalInfo),
      vehicle_uuid: safeString(vehicleId), // ‚úÖ NOVO: Incluir vehicleId
      status: 'available' as const
    };

    console.log('üìù Dados normalizados para ride (COM GEOMETRIAS):', {
      ...rideInput,
      from_geom: rideInput.from_geom ? 'PRESENT' : 'NULL',
      to_geom: rideInput.to_geom ? 'PRESENT' : 'NULL'
    });

    const validatedData = insertRideSchema.parse({
      ...rideInput,
      pricePerSeat: rideInput.pricePerSeat.toString()
    });

    console.log('‚úÖ Dados validados com Zod, criando ride no banco...');

    const newRide = await rideService.createRide(validatedData as any);
    
    console.log('üéâ Ride criada com sucesso no banco:', { 
      rideId: newRide.id,
      driverId,
      vehicle_uuid: body.vehicleId,
      hasGeometries: !!(fromGeom && toGeom)
    });

    res.status(201).json({
      success: true,
      message: 'Viagem criada com sucesso',
      data: { 
        ride: newRide,
        vehicleInfo: {
          id: vehicle.id,
          make: vehicle.make,
          model: vehicle.model,
          color: vehicle.color,
          plateNumber: vehicle.plate_number,
          maxPassengers: vehicle.max_passengers
        },
        // ‚úÖ‚úÖ‚úÖ NOVO: Informa√ß√µes de geometria para debug
        geometryInfo: {
          fromGeom: !!fromGeom,
          toGeom: !!toGeom,
          coordinatesProvided: !!(fromLat && fromLng && toLat && toLng)
        }
      }
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.log('‚ùå Erro de valida√ß√£o Zod:', error.errors);
      logger.warn('‚ùå Valida√ß√£o Zod falhou', { errors: error.errors });
      return res.status(400).json({
        success: false,
        error: 'Dados inv√°lidos',
        details: error.errors
      });
    }

    console.log('‚ùå Erro inesperado ao criar ride:', error);
    logger.error('Erro ao criar viagem:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erro interno do servidor' 
    });
  }
});

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Nova rota para busca inteligente de rides do motorista
// GET /api/provider/rides/smart/search - Busca inteligente para motoristas
router.get('/smart/search', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const driverId = getDriverId(req);
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: NORMALIZAR LOCALIZA√á√ïES ANTES DA BUSCA
    const originalFrom = getQueryString(req.query, 'from');
    const originalTo = getQueryString(req.query, 'to');
    const date = getQueryString(req.query, 'date');
    const radiusKm = getQueryNumber(req.query, 'radiusKm', 100);
    const maxResults = getQueryNumber(req.query, 'maxResults', 50); // ‚úÖ Aumentado para 50

    // ‚úÖ APLICAR NORMALIZA√á√ÉO DO POSTGRESQL
    const normalizedFrom = await normalizeLocation(originalFrom);
    const normalizedTo = await normalizeLocation(originalTo);

    logger.info('üß† PROVIDER: Busca inteligente NORMALIZADA', {
      driverId,
      original: { from: originalFrom, to: originalTo },
      normalized: { from: normalizedFrom, to: normalizedTo },
      date,
      radiusKm,
      maxResults,
      normalizationApplied: originalFrom !== normalizedFrom || originalTo !== normalizedTo
    });

    let matchingRides: any[] = [];
    let searchMethod = 'smart_final';

    try {
      // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Usar RPC para busca SMART FINAL com nomes NORMALIZADOS
      matchingRides = await callPostgresFunction('get_rides_smart_final', [
        normalizedFrom,
        normalizedTo,
        radiusKm,
        maxResults
      ]);
      searchMethod = 'smart_final_normalized';
    } catch (smartError) {
      console.warn("‚ùå PROVIDER: Smart final falhou, usando universal como fallback:", smartError);
      matchingRides = await rideService.getRidesUniversal({
        fromLocation: normalizedFrom,
        toLocation: normalizedTo,
        radiusKm: radiusKm,
        maxResults: maxResults
      });
      searchMethod = 'universal_fallback';
    }

    // ‚úÖ Filtrar por data se fornecida
    if (date) {
      const searchDate = new Date(date);
      matchingRides = matchingRides.filter(ride => {
        if (!ride.departureDate) return false;
        const rideDate = new Date(ride.departureDate);
        return rideDate.toDateString() === searchDate.toDateString();
      });
    }

    // ‚úÖ Aplicar limite de resultados
    matchingRides = matchingRides.slice(0, maxResults);

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: ESTAT√çSTICAS ATUALIZADAS COM DADOS DA FUN√á√ÉO INTELIGENTE
    const matchStats = {
      exact_match: matchingRides.filter(r => r.match_type === 'exact_match').length,
      exact_province: matchingRides.filter(r => r.match_type === 'exact_province').length,
      from_correct_province_to: matchingRides.filter(r => r.match_type === 'from_correct_province_to').length,
      to_correct_province_from: matchingRides.filter(r => r.match_type === 'to_correct_province_from').length,
      partial_from: matchingRides.filter(r => r.match_type === 'partial_from').length,
      partial_to: matchingRides.filter(r => r.match_type === 'partial_to').length,
      nearby: matchingRides.filter(r => r.match_type === 'nearby').length,
      all_rides: matchingRides.filter(r => r.match_type === 'all_rides').length,
      other: matchingRides.filter(r => r.match_type === 'other').length,
      total: matchingRides.length,
      // ‚úÖ NOVAS ESTAT√çSTICAS: Dados dos motoristas e ve√≠culos
      drivers_with_ratings: matchingRides.filter(r => r.driver_rating && r.driver_rating > 0).length,
      average_driver_rating: matchingRides.length > 0 
        ? parseFloat((matchingRides.reduce((sum, ride) => sum + (safeNumber(ride.driver_rating) || 0), 0) / matchingRides.length).toFixed(1))
        : 0,
      average_direction_score: matchingRides.length > 0 
        ? Math.round(matchingRides.reduce((sum, ride) => sum + (safeNumber(ride.direction_score) || 0), 0) / matchingRides.length)
        : 0,
      vehicle_types: matchingRides.reduce((acc: any, ride) => {
        const type = ride.vehicle_type || ride.vehicleType || 'unknown';
        acc[type] = (acc[type] || 0) + 1;
        return acc;
      }, {})
    };

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: DEBUG COM DADOS COMPLETOS DA FUN√á√ÉO INTELIGENTE
    console.log('üéØ [PROVIDER-SMART-SEARCH] Resultados com dados completos:', {
      totalResults: matchingRides.length,
      sampleResults: matchingRides.slice(0, 3).map(ride => ({
        driverName: ride.driver_name || ride.driverName,
        driverRating: ride.driver_rating || ride.driverRating,
        vehicle: ride.vehicle_make ? `${ride.vehicle_make} ${ride.vehicle_model}` : 'N/A',
        vehicleType: ride.vehicle_type || 'N/A',
        price: ride.priceperseat || ride.pricePerSeat,
        match_type: ride.match_type,
        direction_score: ride.direction_score,
        // ‚úÖ‚úÖ‚úÖ NOVO: Informa√ß√µes de geometria
        hasFromGeom: !!ride.from_geom,
        hasToGeom: !!ride.to_geom
      })),
      stats: matchStats
    });

    logger.info('‚úÖ PROVIDER: Busca inteligente conclu√≠da', {
      driverId,
      total: matchingRides.length,
      method: searchMethod,
      stats: matchStats,
      normalization: {
        applied: originalFrom !== normalizedFrom || originalTo !== normalizedTo,
        original: { from: originalFrom, to: originalTo },
        normalized: { from: normalizedFrom, to: normalizedTo }
      }
    });

    res.json({
      success: true,
      data: {
        rides: matchingRides,
        stats: matchStats,
        searchParams: {
          from: originalFrom,
          to: originalTo,
          normalizedFrom,
          normalizedTo,
          date: date || 'qualquer',
          radiusKm,
          maxResults,
          searchMethod
        },
        normalization: {
          applied: originalFrom !== normalizedFrom || originalTo !== normalizedTo,
          original: { from: originalFrom, to: originalTo },
          normalized: { from: normalizedFrom, to: normalizedTo }
        },
        data_completeness: {
          driver_names: matchingRides.filter(r => r.driver_name && r.driver_name !== 'Motorista').length,
          driver_ratings: matchingRides.filter(r => r.driver_rating && safeNumber(r.driver_rating) > 0).length,
          vehicle_data: matchingRides.filter(r => r.vehicle_make && r.vehicle_model).length,
          prices: matchingRides.filter(r => r.priceperseat && safeNumber(r.priceperseat) > 0).length,
          direction_scores: matchingRides.filter(r => r.direction_score && safeNumber(r.direction_score) > 0).length,
          // ‚úÖ‚úÖ‚úÖ NOVO: Estat√≠sticas de geometria
          from_geometries: matchingRides.filter(r => r.from_geom).length,
          to_geometries: matchingRides.filter(r => r.to_geom).length
        },
        smart_search: true,
        smart_function_used: true
      }
    });
  } catch (error) {
    logger.error('‚ùå PROVIDER: Erro em busca inteligente:', error);
    
    try {
      const { from, to, maxResults = '50' } = req.query;
      
      // ‚úÖ CORRE√á√ÉO: Aplicar normaliza√ß√£o do PostgreSQL mesmo no fallback
      const normalizedFromFallback = await normalizeLocation(from as string);
      const normalizedToFallback = await normalizeLocation(to as string);
      
      const traditionalRides = await rideService.getRides({
        fromLocation: normalizedFromFallback,
        toLocation: normalizedToFallback,
        status: 'available'
      }).then(rides => rides.slice(0, safeNumber(maxResults, 50)));

      res.json({
        success: true,
        data: {
          rides: traditionalRides,
          stats: {
            exact_match: 0,
            same_segment: 0,
            same_direction: 0,
            potential: 0,
            traditional: traditionalRides.length,
            total: traditionalRides.length
          },
          searchParams: {
            from: from as string,
            to: to as string,
            normalizedFrom: normalizedFromFallback,
            normalizedTo: normalizedToFallback,
            maxResults: safeNumber(maxResults, 50)
          },
          normalization: {
            applied: (from as string) !== normalizedFromFallback || (to as string) !== normalizedToFallback,
            original: { from: from as string, to: to as string },
            normalized: { from: normalizedFromFallback, to: normalizedToFallback }
          },
          warning: "Sistema inteligente temporariamente indispon√≠vel, usando busca tradicional"
        }
      });
    } catch (fallbackError) {
      res.status(500).json({
        success: false,
        error: "Erro interno do servidor no sistema de busca"
      });
    }
  }
});

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Nova rota para an√°lise de mercado do motorista
// GET /api/provider/rides/market-analysis - An√°lise de mercado para motoristas
router.get('/market-analysis', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const driverId = getDriverId(req);
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: NORMALIZAR LOCALIZA√á√µes PARA AN√ÅLISE DE MERCADO
    const originalFrom = getQueryString(req.query, 'from');
    const originalTo = getQueryString(req.query, 'to');
    const radiusKm = getQueryNumber(req.query, 'radiusKm', 100);

    const normalizedFrom = await normalizeLocation(originalFrom);
    const normalizedTo = await normalizeLocation(originalTo);

    logger.info('üìä PROVIDER: An√°lise de mercado NORMALIZADA', {
      driverId,
      original: { from: originalFrom, to: originalTo },
      normalized: { from: normalizedFrom, to: normalizedTo },
      radiusKm,
      normalizationApplied: originalFrom !== normalizedFrom || originalTo !== normalizedTo
    });

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Usar RPC para busca SMART FINAL com nomes NORMALIZADOS
    let marketRides: any[] = [];
    
    try {
      marketRides = await callPostgresFunction('get_rides_smart_final', [
        normalizedFrom,
        normalizedTo,
        radiusKm,
        50
      ]);
    } catch (smartError) {
      console.warn("‚ùå PROVIDER: Smart final falhou na an√°lise, usando universal:", smartError);
      marketRides = await rideService.getRidesUniversal({
        fromLocation: normalizedFrom,
        toLocation: normalizedTo,
        radiusKm: radiusKm,
        maxResults: 50
      });
    }

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: AN√ÅLISE COMPLETA COM NOVOS DADOS DA FUN√á√ÉO INTELIGENTE
    const prices = marketRides
      .filter(ride => safeNumber(ride.priceperseat || ride.pricePerSeat) > 0)
      .map(ride => safeNumber(ride.priceperseat || ride.pricePerSeat));
    
    const averagePrice = prices.length > 0 
      ? prices.reduce((sum, price) => sum + price, 0) / prices.length 
      : 0;
    
    const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
    const maxPrice = prices.length > 0 ? Math.max(...prices) : 0;

    // ‚úÖ An√°lise de demanda
    const totalAvailableSeats = marketRides.reduce((sum, ride) => sum + safeNumber(ride.availableseats || ride.availableSeats), 0);
    const totalRides = marketRides.length;
    
    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: AN√ÅLISE DE MOTORISTAS E VE√çCULOS COMPLETA
    const vehicleTypes = marketRides.reduce((acc, ride) => {
      const type = ride.vehicle_type || ride.vehicleType || 'desconhecido';
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // ‚úÖ An√°lise de ratings dos motoristas
    const driverRatings = marketRides
      .filter(ride => safeNumber(ride.driver_rating || ride.driverRating) > 0)
      .map(ride => safeNumber(ride.driver_rating || ride.driverRating));
    
    const averageDriverRating = driverRatings.length > 0 
      ? driverRatings.reduce((sum, rating) => sum + rating, 0) / driverRatings.length 
      : 0;

    // ‚úÖ An√°lise de direction scores
    const directionScores = marketRides
      .filter(ride => safeNumber(ride.direction_score) > 0)
      .map(ride => safeNumber(ride.direction_score));
    
    const averageDirectionScore = directionScores.length > 0 
      ? directionScores.reduce((sum, score) => sum + score, 0) / directionScores.length 
      : 0;

    // ‚úÖ An√°lise de datas
    const upcomingRides = marketRides.filter(ride => {
      const departureDate = safeDate(ride.departuredate || ride.departureDate);
      return departureDate >= new Date();
    }).length;

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: AN√ÅLISE DE MERCADO COMPLETA COM NOVOS DADOS
    const marketAnalysis = {
      route: { from: originalFrom, to: originalTo, normalizedFrom, normalizedTo },
      pricing: {
        average: Math.round(averagePrice),
        min: Math.round(minPrice),
        max: Math.round(maxPrice),
        recommendation: averagePrice > 0 
          ? `Pre√ßo sugerido: ${Math.round(averagePrice * 0.9)} - ${Math.round(averagePrice * 1.1)} MZN`
          : 'Dados insuficientes para recomenda√ß√£o'
      },
      demand: {
        totalRides,
        totalAvailableSeats,
        demandLevel: totalRides === 0 ? 'baixa' : 
                    totalRides < 5 ? 'm√©dia' : 'alta',
        recommendation: totalRides === 0 
          ? '√ìtima oportunidade - pouca concorr√™ncia'
          : `Mercado ${totalRides < 5 ? 'moderado' : 'competitivo'} - ${totalRides} rides ativas`
      },
      drivers: {
        totalUnique: new Set(marketRides.map(ride => ride.driver_id || ride.driverId)).size,
        averageRating: parseFloat(averageDriverRating.toFixed(1)),
        averageDirectionScore: Math.round(averageDirectionScore),
        recommendation: averageDriverRating > 4.5 
          ? 'Mercado com motoristas bem avaliados - mantenha alta qualidade'
          : 'Oportunidade para se destacar com bom atendimento'
      },
      vehicles: {
        types: vehicleTypes,
        mostCommon: Object.keys(vehicleTypes).length > 0 
          ? Object.keys(vehicleTypes).reduce((a, b) => vehicleTypes[a] > vehicleTypes[b] ? a : b)
          : 'desconhecido',
        recommendation: Object.keys(vehicleTypes).length > 0 
          ? `Ve√≠culo mais comum: ${Object.keys(vehicleTypes).reduce((a, b) => vehicleTypes[a] > vehicleTypes[b] ? a : b)}`
          : 'Diversidade de ve√≠culos no mercado'
      },
      timing: {
        upcomingRides,
        recommendation: upcomingRides === 0 
          ? 'Hor√°rios flex√≠veis - baixa competi√ß√£o'
          : `Considere hor√°rios alternativos - ${upcomingRides} rides futuras`
      },
      match_quality: {
        averageDirectionScore: Math.round(averageDirectionScore),
        qualityLevel: averageDirectionScore >= 80 ? 'alta' : averageDirectionScore >= 60 ? 'm√©dia' : 'baixa',
        recommendation: averageDirectionScore >= 80 
          ? 'Mercado com alta qualidade de correspond√™ncia'
          : 'Oportunidade para oferecer rotas mais precisas'
      },
      // ‚úÖ‚úÖ‚úÖ NOVO: An√°lise de geometrias
      geometry_analysis: {
        rides_with_geometries: marketRides.filter(r => r.from_geom && r.to_geom).length,
        geometry_coverage: totalRides > 0 ? Math.round((marketRides.filter(r => r.from_geom && r.to_geom).length / totalRides) * 100) : 0,
        recommendation: marketRides.filter(r => r.from_geom && r.to_geom).length === 0 
          ? '‚ö†Ô∏è Nenhuma ride com geometrias - buscas podem n√£o funcionar corretamente'
          : `‚úÖ ${marketRides.filter(r => r.from_geom && r.to_geom).length}/${totalRides} rides com geometrias`
      }
    };

    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: DEBUG DETALHADO DA AN√ÅLISE
    console.log('üìä [PROVIDER-MARKET-ANALYSIS] An√°lise completa:', {
      totalRides,
      averagePrice: marketAnalysis.pricing.average,
      driverStats: marketAnalysis.drivers,
      vehicleStats: marketAnalysis.vehicles,
      matchQuality: marketAnalysis.match_quality,
      geometryStats: marketAnalysis.geometry_analysis,
      sampleRides: marketRides.slice(0, 3).map(ride => ({
        driverName: ride.driver_name || ride.driverName,
        driverRating: ride.driver_rating || ride.driverRating,
        vehicle: ride.vehicle_make ? `${ride.vehicle_make} ${ride.vehicle_model}` : 'N/A',
        price: ride.priceperseat || ride.pricePerSeat,
        direction_score: ride.direction_score,
        hasGeometries: !!(ride.from_geom && ride.to_geom)
      }))
    });

    logger.info('‚úÖ PROVIDER: An√°lise de mercado conclu√≠da', {
      driverId,
      totalRides,
      averagePrice: marketAnalysis.pricing.average,
      averageDriverRating: marketAnalysis.drivers.averageRating,
      averageDirectionScore: marketAnalysis.drivers.averageDirectionScore,
      geometryCoverage: marketAnalysis.geometry_analysis.geometry_coverage,
      normalization: {
        applied: originalFrom !== normalizedFrom || originalTo !== normalizedTo,
        original: { from: originalFrom, to: originalTo },
        normalized: { from: normalizedFrom, to: normalizedTo }
      }
    });

    res.json({
      success: true,
      data: {
        analysis: marketAnalysis,
        sampleRides: marketRides.slice(0, 5).map(ride => ({
          id: ride.ride_id || ride.id,
          driverName: ride.driver_name || ride.driverName,
          driverRating: ride.driver_rating || ride.driverRating,
          vehicleInfo: ride.vehicle_make ? {
            make: ride.vehicle_make,
            model: ride.vehicle_model,
            type: ride.vehicle_type
          } : ride.vehicleInfo,
          pricePerSeat: ride.priceperseat || ride.pricePerSeat,
          availableSeats: ride.availableseats || ride.availableSeats,
          departureDate: ride.departuredate || ride.departureDate,
          match_type: ride.match_type,
          direction_score: ride.direction_score,
          // ‚úÖ‚úÖ‚úÖ NOVO: Informa√ß√µes de geometria
          hasGeometries: !!(ride.from_geom && ride.to_geom)
        })),
        searchParams: {
          from: originalFrom,
          to: originalTo,
          normalizedFrom,
          normalizedTo,
          radiusKm,
          totalRidesAnalyzed: marketRides.length
        },
        normalization: {
          applied: originalFrom !== normalizedFrom || originalTo !== normalizedTo,
          original: { from: originalFrom, to: originalTo },
          normalized: { from: normalizedFrom, to: normalizedTo }
        },
        data_completeness: {
          driver_names: marketRides.filter(r => r.driver_name && r.driver_name !== 'Motorista').length,
          driver_ratings: marketRides.filter(r => r.driver_rating && safeNumber(r.driver_rating) > 0).length,
          vehicle_data: marketRides.filter(r => r.vehicle_make && r.vehicle_model).length,
          prices: marketRides.filter(r => r.priceperseat && safeNumber(r.priceperseat) > 0).length,
          direction_scores: marketRides.filter(r => r.direction_score && safeNumber(r.direction_score) > 0).length,
          // ‚úÖ‚úÖ‚úÖ NOVO: Estat√≠sticas de geometria
          from_geometries: marketRides.filter(r => r.from_geom).length,
          to_geometries: marketRides.filter(r => r.to_geom).length,
          both_geometries: marketRides.filter(r => r.from_geom && r.to_geom).length
        },
        smart_analysis: true,
        smart_function_used: true
      }
    });
  } catch (error) {
    logger.error('‚ùå PROVIDER: Erro na an√°lise de mercado:', error);
    res.status(500).json({
      success: false,
      error: "Erro interno do servidor na an√°lise de mercado"
    });
  }
});

// Rotas espec√≠ficas primeiro
router.get('/driver/stats', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const driverId = getDriverId(req);
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }

    logger.info('üìä Buscando estat√≠sticas do motorista', { driverId });

    const driverRides = await rideService.getRidesByDriver(driverId);

    const totalRides = driverRides.length;
    const availableRides = driverRides.filter(ride => safeString(ride.status) === 'available').length;
    const completedRides = driverRides.filter(ride => safeString(ride.status) === 'completed').length;
    const cancelledRides = driverRides.filter(ride => safeString(ride.status) === 'cancelled').length;

    const totalRevenue = driverRides
      .filter(ride => safeString(ride.status) === 'completed')
      .reduce((sum, ride) => sum + calculateRideRevenue(ride), 0);

    const ratings = driverRides
      .filter(ride => safeNumber(ride.driverRating) > 0)
      .map(ride => safeNumber(ride.driverRating));
    
    const averageRating = ratings.length > 0 
      ? ratings.reduce((sum, rating) => sum + rating, 0) / ratings.length 
      : 4.8;

    logger.info('‚úÖ Estat√≠sticas calculadas com sucesso', {
      driverId,
      totalRides,
      completedRides,
      totalRevenue
    });

    res.json({
      success: true,
      data: {
        stats: {
          totalRides,
          availableRides,
          completedRides,
          cancelledRides,
          totalRevenue,
          averageRating: Math.round(averageRating * 10) / 10
        }
      }
    });
  } catch (error) {
    logger.error('Erro ao buscar estat√≠sticas:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erro interno do servidor' 
    });
  }
});

router.get('/dashboard/summary', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const driverId = getDriverId(req);
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }

    logger.info('üìà Buscando resumo do dashboard', { driverId });

    const driverRides = await rideService.getRidesByDriver(driverId);
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const activeToday = driverRides.filter(ride => {
      const departureDate = safeDate(ride.departureDate);
      if (!departureDate) return false;
      
      const rideDate = new Date(departureDate);
      rideDate.setHours(0, 0, 0, 0);
      
      const rideStatus = safeString(ride.status);
      return rideDate.getTime() === today.getTime() && 
             (rideStatus === 'available' || rideStatus === 'active');
    }).length;

    const upcomingRides = driverRides
      .filter(ride => {
        const departureDate = safeDate(ride.departureDate);
        if (!departureDate) return false;
        
        const rideStatus = safeString(ride.status);
        return departureDate >= new Date() && rideStatus === 'available';
      })
      .slice(0, 5);

    const totalEarnings = driverRides
      .filter(ride => safeString(ride.status) === 'completed')
      .reduce((sum, ride) => sum + calculateRideRevenue(ride), 0);

    logger.info('‚úÖ Resumo do dashboard gerado com sucesso', {
      driverId,
      activeToday,
      upcomingRides: upcomingRides.length,
      totalEarnings
    });

    res.json({
      success: true,
      data: {
        summary: {
          activeToday,
          totalRides: driverRides.length,
          upcomingRides: upcomingRides.length,
          totalEarnings
        },
        upcomingRides
      }
    });
  } catch (error) {
    logger.error('Erro ao buscar resumo do dashboard:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erro interno do servidor' 
    });
  }
});

// GET /api/provider/rides - Listar viagens do motorista
router.get('/', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const driverId = getDriverId(req);
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }
    
    const status = getQueryString(req.query, 'status');
    const page = getQueryNumber(req.query, 'page', 1);
    const limit = getQueryNumber(req.query, 'limit', 10);
    
    logger.info('üìã Listando viagens do motorista', {
      driverId,
      status,
      page,
      limit
    });

    const driverRides = await rideService.getRidesByDriver(driverId, status);
    
    // ‚úÖ CORRE√á√ÉO APLICADA: Usar safeNumber para garantir que s√£o n√∫meros
    const pageNum = Math.max(safeNumber(page), 1);
    const limitNum = Math.min(Math.max(safeNumber(limit), 1), 100);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedRides = driverRides.slice(startIndex, endIndex);
    
    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: DEBUG COM DADOS COMPLETOS
    console.log('üìã [PROVIDER-RIDES-LIST] Rides do motorista:', {
      total: driverRides.length,
      returned: paginatedRides.length,
      sampleRides: paginatedRides.slice(0, 3).map(ride => ({
        id: ride.id,
        driverName: ride.driverName,
        driverRating: ride.driverRating,
        vehicle: ride.vehicleInfo ? `${ride.vehicleInfo.make} ${ride.vehicleInfo.model}` : 'N/A',
        price: ride.pricePerSeat,
        status: ride.status,
        // ‚úÖ‚úÖ‚úÖ NOVO: Informa√ß√µes de geometria
        hasFromGeom: !!ride.from_geom,
        hasToGeom: !!ride.to_geom
      }))
    });

    logger.info('‚úÖ Listagem de viagens conclu√≠da', {
      driverId,
      total: driverRides.length,
      returned: paginatedRides.length
    });

    res.json({
      success: true,
      data: {
        rides: paginatedRides,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: driverRides.length,
          totalPages: Math.ceil(driverRides.length / limitNum)
        },
        data_completeness: {
          driver_names: paginatedRides.filter(r => r.driverName && r.driverName !== 'Motorista').length,
          driver_ratings: paginatedRides.filter(r => r.driverRating && safeNumber(r.driverRating) > 0).length,
          vehicle_data: paginatedRides.filter(r => r.vehicleInfo && r.vehicleInfo.make).length,
          prices: paginatedRides.filter(r => r.pricePerSeat && safeNumber(r.pricePerSeat) > 0).length,
          // ‚úÖ‚úÖ‚úÖ NOVO: Estat√≠sticas de geometria
          from_geometries: paginatedRides.filter(r => r.from_geom).length,
          to_geometries: paginatedRides.filter(r => r.to_geom).length,
          both_geometries: paginatedRides.filter(r => r.from_geom && r.to_geom).length
        }
      }
    });
  } catch (error) {
    logger.error('Erro ao buscar viagens:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erro interno do servidor' 
    });
  }
});

// PUT /api/provider/rides/:id - Atualizar viagem
router.put('/:id', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const driverId = getDriverId(req);
    const body = req.body;
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }
    
    const rideId = safeString(id);
    if (!rideId) {
      return res.status(400).json({
        success: false,
        error: 'ID da viagem √© obrigat√≥rio'
      });
    }
    
    logger.info('‚úèÔ∏è Iniciando atualiza√ß√£o de ride', { driverId, rideId });

    const { ride: existingRide, isOwner } = await verifyRideOwnership(rideId, driverId);

    if (!existingRide) {
      return res.status(404).json({
        success: false,
        error: 'Viagem n√£o encontrada'
      });
    }
    
    if (!isOwner) {
      logger.warn('üö´ Tentativa de editar ride n√£o pertencente ao motorista', {
        driverId,
        rideOwner: existingRide.driverId,
        rideId
      });
      return res.status(403).json({
        success: false,
        error: 'Sem permiss√£o para editar esta viagem'
      });
    }

    const updateData: any = {
      ...body,
      ...(body.maxPassengers !== undefined && { 
        maxPassengers: safeNumber(body.maxPassengers, safeNumber(existingRide.maxPassengers))
      }),
      ...(body.availableSeats !== undefined && { 
        availableSeats: safeNumber(body.availableSeats, safeNumber(existingRide.availableSeats))
      }),
      ...(body.pricePerSeat !== undefined && { 
        pricePerSeat: safeNumber(body.pricePerSeat, safeNumber(existingRide.pricePerSeat))
      }),
      ...(body.departureDate !== undefined && { 
        departureDate: safeDate(body.departureDate)
      }),
      ...(body.fromProvince !== undefined && { 
        fromProvince: normalizeLocationField(body.fromProvince)
      }),
      ...(body.toProvince !== undefined && { 
        toProvince: normalizeLocationField(body.toProvince)
      }),
      ...(body.fromCity !== undefined && { 
        fromCity: normalizeLocationField(body.fromCity)
      }),
      ...(body.toCity !== undefined && { 
        toCity: normalizeLocationField(body.toCity)
      }),
      ...(body.fromLocality !== undefined && { 
        fromLocality: normalizeLocationField(body.fromLocality)
      }),
      ...(body.toLocality !== undefined && { 
        toLocality: normalizeLocationField(body.toLocality)
      }),
      // ‚úÖ‚úÖ‚úÖ NOVO: Atualizar geometrias se coordenadas forem fornecidas
      ...(body.fromLat !== undefined && body.fromLng !== undefined && { 
        from_geom: createGeometryFromCoords(body.fromLat, body.fromLng)
      }),
      ...(body.toLat !== undefined && body.toLng !== undefined && { 
        to_geom: createGeometryFromCoords(body.toLat, body.toLng)
      }),
    };

    const validatedUpdateData = updateRideSchema.partial().parse({
      ...updateData,
      ...(updateData.pricePerSeat !== undefined && { 
        pricePerSeat: updateData.pricePerSeat.toString() 
      })
    });

    const updatedRide = await rideService.updateRide(rideId, validatedUpdateData as any);

    if (!updatedRide) {
      return res.status(500).json({
        success: false,
        error: 'Erro ao atualizar viagem'
      });
    }
    
    logger.info(`‚úÖ Viagem atualizada com sucesso`, { driverId, rideId });

    res.json({
      success: true,
      message: 'Viagem atualizada com sucesso',
      data: { ride: updatedRide }
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      logger.warn('‚ùå Valida√ß√£o Zod falhou na atualiza√ß√£o', { errors: error.errors });
      return res.status(400).json({
        success: false,
        error: 'Dados inv√°lidos',
        details: error.errors
      });
    }

    logger.error('Erro ao atualizar viagem:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erro interno do servidor' 
    });
  }
});

// DELETE /api/provider/rides/:id - Cancelar viagem
router.delete('/:id', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const driverId = getDriverId(req);
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }
    
    const rideId = safeString(id);
    if (!rideId) {
      return res.status(400).json({
        success: false,
        error: 'ID da viagem √© obrigat√≥rio'
      });
    }
    
    logger.info('üóëÔ∏è Iniciando cancelamento de ride', { driverId, rideId });

    const { ride: existingRide, isOwner } = await verifyRideOwnership(rideId, driverId);

    if (!existingRide) {
      return res.status(404).json({
        success: false,
        error: 'Viagem n√£o encontrada'
      });
    }
    
    if (!isOwner) {
      logger.warn('üö´ Tentativa de cancelar ride n√£o pertencente ao motorista', {
        driverId,
        rideOwner: existingRide.driverId,
        rideId
      });
      return res.status(403).json({
        success: false,
        error: 'Sem permiss√£o para cancelar esta viagem'
      });
    }
    
    const rideStatus = safeString(existingRide.status);
    const cancellableStatuses = ['available', 'active', 'pending', 'confirmed'];
    
    if (!cancellableStatuses.includes(rideStatus)) {
      return res.status(400).json({
        success: false,
        error: `N√£o √© poss√≠vel cancelar viagens com status "${rideStatus}". Status cancel√°veis: ${cancellableStatuses.join(', ')}`
      });
    }
    
    const cancelled = await rideService.updateRide(rideId, { 
      status: 'cancelled',
      cancelledAt: new Date().toISOString()
    } as any);
    
    if (!cancelled) {
      return res.status(500).json({
        success: false,
        error: 'Erro ao cancelar viagem'
      });
    }
    
    logger.info(`‚úÖ Viagem cancelada com sucesso`, { driverId, rideId });

    res.json({
      success: true,
      message: 'Viagem cancelada com sucesso',
      data: {
        rideId,
        cancelledAt: new Date().toISOString()
      }
    });
  } catch (error) {
    logger.error('Erro ao cancelar viagem:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erro interno do servidor' 
    });
  }
});

// GET /api/provider/rides/:id - Obter detalhes de uma viagem espec√≠fica
router.get('/:id', verifyFirebaseToken, requireDriverRole, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const driverId = getDriverId(req);
    
    if (!driverId) {
      return res.status(401).json({ 
        success: false,
        error: 'Usu√°rio n√£o autenticado' 
      });
    }
    
    const rideId = safeString(id);
    if (!rideId) {
      return res.status(400).json({
        success: false,
        error: 'ID da viagem √© obrigat√≥rio'
      });
    }
    
    logger.info('üîç Buscando detalhes da ride', { driverId, rideId });

    const { ride, isOwner } = await verifyRideOwnership(rideId, driverId);
    
    if (!ride) {
      return res.status(404).json({
        success: false,
        error: 'Viagem n√£o encontrada'
      });
    }
    
    if (!isOwner) {
      logger.warn('üö´ Tentativa de acessar ride n√£o pertencente ao motorista', {
        driverId,
        rideOwner: ride.driverId,
        rideId
      });
      return res.status(403).json({
        success: false,
        error: 'Sem permiss√£o para visualizar esta viagem'
      });
    }
    
    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: DEBUG COM DADOS COMPLETOS
    console.log('üîç [PROVIDER-RIDE-DETAILS] Detalhes completos da ride:', {
      rideId,
      driverName: ride.driverName,
      driverRating: ride.driverRating,
      vehicleInfo: ride.vehicleInfo,
      price: ride.pricePerSeat,
      status: ride.status,
      // ‚úÖ‚úÖ‚úÖ NOVO: Informa√ß√µes de geometria
      hasFromGeom: !!ride.from_geom,
      hasToGeom: !!ride.to_geom
    });

    logger.info('‚úÖ Detalhes da ride retornados com sucesso', { driverId, rideId });

    res.json({
      success: true,
      data: { 
        ride,
        data_completeness: {
          has_driver_name: !!ride.driverName && ride.driverName !== 'Motorista',
          has_driver_rating: !!ride.driverRating && safeNumber(ride.driverRating) > 0,
          has_vehicle_data: !!ride.vehicleInfo && !!ride.vehicleInfo.make,
          has_price: !!ride.pricePerSeat && safeNumber(ride.pricePerSeat) > 0,
          // ‚úÖ‚úÖ‚úÖ NOVO: Informa√ß√µes de geometria
          has_from_geometry: !!ride.from_geom,
          has_to_geometry: !!ride.to_geom
        }
      }
    });
  } catch (error) {
    logger.error('Erro ao buscar detalhes da viagem:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erro interno do servidor' 
    });
  }
});

export default router;